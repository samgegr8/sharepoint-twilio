{"version":3,"file":"index.min.js","mappings":"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","sources":["webpack://axios-auth-refresh/webpack/universalModuleDefinition","webpack://axios-auth-refresh/./src/utils.ts","webpack://axios-auth-refresh/external umd \"axios\"","webpack://axios-auth-refresh/webpack/bootstrap","webpack://axios-auth-refresh/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"axios\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"axios\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"axios-auth-refresh\"] = factory(require(\"axios\"));\n\telse\n\t\troot[\"axios-auth-refresh\"] = factory(root[\"axios\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__300__) {\nreturn ","import axios, { AxiosInstance, AxiosPromise, AxiosRequestConfig } from 'axios';\nimport { AxiosAuthRefreshOptions, AxiosAuthRefreshCache } from './model';\n\nexport interface CustomAxiosRequestConfig extends AxiosRequestConfig {\n    skipAuthRefresh?: boolean;\n}\n\nexport const defaultOptions: AxiosAuthRefreshOptions = {\n    statusCodes: [401],\n    pauseInstanceWhileRefreshing: false,\n};\n\n/**\n * Merges two options objects (options overwrites defaults).\n *\n * @return {AxiosAuthRefreshOptions}\n */\nexport function mergeOptions(\n    defaults: AxiosAuthRefreshOptions,\n    options: AxiosAuthRefreshOptions\n): AxiosAuthRefreshOptions {\n    return {\n        ...defaults,\n        pauseInstanceWhileRefreshing: options.skipWhileRefreshing,\n        ...options,\n    };\n}\n\n/**\n * Returns TRUE: when error.response.status is contained in options.statusCodes\n * Returns FALSE: when error or error.response doesn't exist or options.statusCodes doesn't include response status\n *\n * @return {boolean}\n */\nexport function shouldInterceptError(\n    error: any,\n    options: AxiosAuthRefreshOptions,\n    instance: AxiosInstance,\n    cache: AxiosAuthRefreshCache\n): boolean {\n    if (!error) {\n        return false;\n    }\n\n    if (error.config?.skipAuthRefresh) {\n        return false;\n    }\n\n    if (\n        !(options.interceptNetworkError && !error.response && error.request.status === 0) &&\n        (!error.response ||\n            (options?.shouldRefresh\n                ? !options.shouldRefresh(error)\n                : !options.statusCodes?.includes(parseInt(error.response.status))))\n    ) {\n        return false;\n    }\n\n    // Copy config to response if there's a network error, so config can be modified and used in the retry\n    if (!error.response) {\n        error.response = {\n            config: error.config,\n        };\n    }\n\n    return !options.pauseInstanceWhileRefreshing || !cache.skipInstances.includes(instance);\n}\n\n/**\n * Creates refresh call if it does not exist or returns the existing one.\n *\n * @return {Promise<any>}\n */\nexport function createRefreshCall(\n    error: any,\n    fn: (error: any) => Promise<any>,\n    cache: AxiosAuthRefreshCache\n): Promise<any> {\n    if (!cache.refreshCall) {\n        cache.refreshCall = fn(error);\n        if (typeof cache.refreshCall.then !== 'function') {\n            console.warn('axios-auth-refresh requires `refreshTokenCall` to return a promise.');\n            return Promise.reject();\n        }\n    }\n    return cache.refreshCall;\n}\n\n/**\n * Creates request queue interceptor if it does not exist and returns its id.\n *\n * @return {number}\n */\nexport function createRequestQueueInterceptor(\n    instance: AxiosInstance,\n    cache: AxiosAuthRefreshCache,\n    options: AxiosAuthRefreshOptions\n): number {\n    if (typeof cache.requestQueueInterceptorId === 'undefined') {\n        cache.requestQueueInterceptorId = instance.interceptors.request.use((request: CustomAxiosRequestConfig) => {\n            return cache.refreshCall\n                .catch(() => {\n                    throw new axios.Cancel('Request call failed');\n                })\n                .then(() => (options.onRetry ? options.onRetry(request) : request));\n        });\n    }\n    return cache.requestQueueInterceptorId;\n}\n\n/**\n * Ejects request queue interceptor and unset interceptor cached values.\n *\n * @param {AxiosInstance} instance\n * @param {AxiosAuthRefreshCache} cache\n */\nexport function unsetCache(instance: AxiosInstance, cache: AxiosAuthRefreshCache): void {\n    instance.interceptors.request.eject(cache.requestQueueInterceptorId);\n    cache.requestQueueInterceptorId = undefined;\n    cache.refreshCall = undefined;\n    cache.skipInstances = cache.skipInstances.filter((skipInstance) => skipInstance !== instance);\n}\n\n/**\n * Returns instance that's going to be used when requests are retried\n *\n * @param instance\n * @param options\n */\nexport function getRetryInstance(instance: AxiosInstance, options: AxiosAuthRefreshOptions): AxiosInstance {\n    return options.retryInstance || instance;\n}\n\n/**\n * Resend failed axios request.\n *\n * @param {any} error\n * @param {AxiosInstance} instance\n * @return AxiosPromise\n */\nexport function resendFailedRequest(error: any, instance: AxiosInstance): AxiosPromise {\n    error.config.skipAuthRefresh = true;\n    return instance(error.response.config);\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__300__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { AxiosInstance, AxiosResponse, AxiosPromise } from 'axios';\nimport { AxiosAuthRefreshOptions, AxiosAuthRefreshCache } from './model';\nimport {\n    unsetCache,\n    mergeOptions,\n    defaultOptions,\n    getRetryInstance,\n    createRefreshCall,\n    resendFailedRequest,\n    shouldInterceptError,\n    createRequestQueueInterceptor,\n} from './utils';\n\nexport { AxiosAuthRefreshOptions, AxiosAuthRefreshRequestConfig } from './model';\n\n/**\n * Creates an authentication refresh interceptor that binds to any error response.\n * If the response status code is one of the options.statusCodes, interceptor calls the refreshAuthCall\n * which must return a Promise. While refreshAuthCall is running, all the new requests are intercepted and are waiting\n * for the refresh call to resolve. While running the refreshing call, instance provided is marked as a paused instance\n * which indicates the interceptor to not intercept any responses from it. This is because you'd otherwise need to mark\n * the specific requests you make by yourself in order to make sure it's not intercepted. This behavior can be\n * turned off, but use it with caution as you need to mark the requests with `skipAuthRefresh` flag yourself in order to\n * not run into interceptors loop.\n *\n * @param {AxiosInstance} instance - Axios HTTP client instance\n * @param {(error: any) => Promise<AxiosPromise>} refreshAuthCall - refresh token call which must return a Promise\n * @param {AxiosAuthRefreshOptions} options - options for the interceptor @see defaultOptions\n * @return {number} - interceptor id (in case you want to eject it manually)\n */\nexport default function createAuthRefreshInterceptor(\n    instance: AxiosInstance,\n    refreshAuthCall: (error: any) => Promise<any>,\n    options: AxiosAuthRefreshOptions = {}\n): number {\n    if (typeof refreshAuthCall !== 'function') {\n        throw new Error('axios-auth-refresh requires `refreshAuthCall` to be a function that returns a promise.');\n    }\n\n    const cache: AxiosAuthRefreshCache = {\n        skipInstances: [],\n        refreshCall: undefined,\n        requestQueueInterceptorId: undefined,\n    };\n\n    return instance.interceptors.response.use(\n        (response: AxiosResponse) => response,\n        (error: any) => {\n            options = mergeOptions(defaultOptions, options);\n\n            if (!shouldInterceptError(error, options, instance, cache)) {\n                return Promise.reject(error);\n            }\n\n            if (options.pauseInstanceWhileRefreshing) {\n                cache.skipInstances.push(instance);\n            }\n\n            // If refresh call does not exist, create one\n            const refreshing = createRefreshCall(error, refreshAuthCall, cache);\n\n            // Create interceptor that will bind all the others requests until refreshAuthCall is resolved\n            createRequestQueueInterceptor(instance, cache, options);\n\n            return refreshing\n                .catch((error) => Promise.reject(error))\n                .then(() => resendFailedRequest(error, getRetryInstance(instance, options)))\n                .finally(() => unsetCache(instance, cache));\n        }\n    );\n}\n"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__300__","defaultOptions","statusCodes","pauseInstanceWhileRefreshing","defaults","options","skipWhileRefreshing","error","instance","cache","config","skipAuthRefresh","interceptNetworkError","response","request","status","shouldRefresh","includes","parseInt","skipInstances","fn","refreshCall","then","console","warn","Promise","reject","requestQueueInterceptorId","interceptors","use","catch","Cancel","onRetry","eject","undefined","filter","skipInstance","retryInstance","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","refreshAuthCall","Error","mergeOptions","shouldInterceptError","push","refreshing","createRefreshCall","createRequestQueueInterceptor","resendFailedRequest","getRetryInstance","finally","unsetCache"],"sourceRoot":""}